<?php

namespace VarRepresentation;

use RuntimeException;

/**
 * Encodes var_export output into var_representation() output
 */
class Encoder {
    /** @var list<string|array{0:int,1:string,2:int}> the raw tokens from token_get_all */
    protected $tokens;
    /** @var int the last valid index */
    protected $endIndex;
    /** @var string the original raw var_export output */
    protected $raw;
    /** @var int the current offset */
    protected $i = 1;
    /** @var string the built up representation */
    protected $representation = '';

    protected function __construct(string $raw) {
        $this->tokens = self::getTokensWithoutWhitespace($raw);
        $this->endIndex = count($this->tokens);
        $this->raw = $raw;
        unset($this->tokens[0]);
    }

    /**
     * Get tokens without T_WHITESPACE tokens
     * @return list<string|array{0:int,1:string,2:int}>
     */
    public static function getTokensWithoutWhitespace(string $raw): array  {
        $tokens = \token_get_all('<?php ' . $raw);
        foreach ($tokens as $i => $token) {
            if (is_array($token) && $token[0] === T_WHITESPACE) {
                unset($tokens[$i]);
            }
        }
        return array_values($tokens);
    }

    /**
     * Generate a readable var_representation from the original var_export output
     */
    public static function toVarRepresentation(string $raw_string): string
    {
        return (new self($raw_string))->encode();
    }

    /**
     * Encode the entire sequence of tokens
     */
    protected function encode(): string
    {
        $this->encodeValue(0);
        if ($this->i !== count($this->tokens) + 1) {
            throw new RuntimeException("Failed to read token #$this->i of $this->raw: " . var_export($this->tokens[$this->i] ?? null, true));
        }
        return $this->representation;
    }

    /**
     * Read the current token and advance
     * @return string|array{0:int,1:string,2:int}
     */
    private function getToken() {
        $token = $this->tokens[$this->i++];
        if ($token === null) {
            throw new RuntimeException("Unexpected end of tokens in $this->raw");
        }
        return $token;
    }

    /**
     * Read the current token without advancing
     * @return string|array{0:int,1:string,2:int}
     */
    private function peekToken() {
        $token = $this->tokens[$this->i];
        if ($token === null) {
            throw new RuntimeException("Unexpected end of tokens in $this->raw");
        }
        return $token;
    }

    /**
     * Convert a expression representation to the readable representation
     */
    protected function encodeValue(int $depth): void {
        while (true) {
            $token = $this->peekToken();
            if (is_string($token)) {
                if ($token === ')' || $token === ',') {
                    return;
                }
                $this->i++;
                if ($token === '(') {
                    $this->encodeObject($depth);
                    return;
                }
                // TODO: Handle `*` in *RECURSION*, `-`, etc
                $this->representation .= $token;
            } else {
                $this->i++;
                // TODO: Handle PHP_INT_MIN as a multi-part expression, strings, etc
                if (is_array($token)) {
                    switch ($token[0]) {
                        case T_CONSTANT_ENCAPSED_STRING;
                            $this->encodeString($token[1]);
                            break;
                        case T_ARRAY;
                            $next = $this->getToken();
                            if ($next !== '(') {
                                throw $this->createUnexpectedTokenException("'('", $next);
                            }
                            $this->encodeArray($depth);
                            break;
                        case T_STRING;
                            switch ($token[1]) {
                            case 'NULL';
                                $this->representation .= 'null';
                                return;
                                /*
                            case 'stdClass':
                                // $this->encodeLegacyStdClass();
                                $next = $this->getToken();
                                if ($next !== T_DOUBLE_COLON) {
                                    throw $this->createUnexpectedTokenException("'::'", $next);
                                }
                                 */
                            }
                        default:
                            $this->representation .= $token[1];
                    }
                }
            }
            if ($this->i >= $this->endIndex) {
                return;
            }
        }
    }

    /**
     * Unescape a string literal generated by var_export
     */
    public static function unescapeStringRepresentation(string $value): string
    {
        if ($value === '"\0"') {
            return "\0";
        }
        return preg_replace('/\\\\([\'\\\\])/', '\1', (string)substr($value, 1, -1));
    }

    private const CHAR_LOOKUP = [
        "\n" => '\n',
        "\t" => '\t',
        "\r" => '\r',
        "\v" => '\v',
        "\f" => '\f',
    ];

    /**
     * Outputs an encoded string representation
     */
    protected function encodeString(string $prefix): void
    {
        $unescaped_str = self::unescapeStringRepresentation($prefix);
        while ($this->i < $this->endIndex && $this->peekToken() === '.') {
            $this->i++;
            $token = $this->getToken();
            if (!is_array($token) || $token[0] !== T_CONSTANT_ENCAPSED_STRING) {
                throw $this->createUnexpectedTokenException('T_CONSTANT_ENCAPSED_STRING', $token);
            }
            $unescaped_str .= self::unescapeStringRepresentation($token[1]);
        }
        if (!preg_match('/[\\x00-\\x1f\\x7f-\xff]/', $unescaped_str)) {
            // This does not have '"\0"', so it is already a single quoted string
            $this->representation .= $prefix;
            return;
        }
        $this->representation .= '"';
        $this->representation .= preg_replace_callback(
            '/[\\x00-\\x1f\\x7f-\xff\\\\\'"$]/',
            /** @param array{0:string} $match */
            static function (array $match): string {
                $char = $match[0];
                return self::CHAR_LOOKUP[$char] ?? sprintf('\%03o', ord($char));
            },
            $unescaped_str
        );
        $this->representation .= '"';
    }

    /**
     * Encode an array
     */
    protected function encodeArray(int $depth): void {
        $this->representation .= '[';
        while (true) {
            $token = $this->peekToken();
            if ($token === ',') {
                $this->i++;
                $this->representation .= ',';
                continue;
            } elseif ($token === ')') {
                $this->i++;
                $this->representation .= ']';
                return;
            }
            $this->encodeValue($depth + 1);
        }
    }

    /**
     * Throw an exception for an unexpected token
     * @param string|array{0:int,1:string,2:int} $token
     */
    private function createUnexpectedTokenException(string $expected, $token): RuntimeException
    {
        return new RuntimeException("Expected $expected but got " . var_export($token, true) . ' in ' . $this->raw);
    }


    /**
     * Encode an object from a set_state call
     */
    protected function encodeObject(int $depth): void {
        $this->representation .= '(';
        $token = $this->getToken();
        if (!is_array($token) || $token[0] !== T_ARRAY) {
            throw $this->createUnexpectedTokenException('T_ARRAY', $token);
        }
        $token = $this->getToken();
        if ($token !== '(') {
            throw $this->createUnexpectedTokenException("'('", $token);
        }
        $this->encodeArray($depth + 1);
        $token = $this->getToken();
        if ($token !== ')') {
            throw $this->createUnexpectedTokenException("')'", $token);
        }
        $this->representation .= ')';
    }
}
